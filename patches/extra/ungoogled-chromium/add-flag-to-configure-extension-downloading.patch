# Add extension-mime-request-handling chrome://flag to tweak the behavior of
# extension MIME types

--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -247,6 +247,16 @@ const unsigned kOsDesktop = kOsMac | kOs
 const unsigned kOsAura = kOsWin | kOsLinux | kOsCrOS;
 #endif  // USE_AURA || OS_ANDROID
 
+const FeatureEntry::Choice kExtensionHandlingChoices[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Download as regular file",
+     "extension-mime-request-handling",
+     "download-as-regular-file"},
+    {"Always prompt for install",
+     "extension-mime-request-handling",
+     "always-prompt-for-install"},
+};
+
 const FeatureEntry::Choice kTouchEventFeatureDetectionChoices[] = {
     {flags_ui::kGenericExperimentChoiceDisabled, "", ""},
     {flags_ui::kGenericExperimentChoiceEnabled,
@@ -1531,6 +1541,10 @@ const FeatureEntry::Choice kEnableCrOSAc
 //
 // When adding a new choice, add it to the end of the list.
 const FeatureEntry kFeatureEntries[] = {
+    {"extension-mime-request-handling",
+     "Handling of extension MIME type requests",
+     "Used when deciding how to handle a request for a CRX or User Script MIME type",
+     kOsAll, MULTI_VALUE_TYPE(kExtensionHandlingChoices)},
     {"enable-stacked-tab-strip",
      "Enable stacking in tab strip",
      "Forces tabs to be stacked in the tab strip. Otherwise, they follow default behavior.",
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -558,6 +558,7 @@ bool ChromeDownloadManagerDelegate::Shou
     content::DownloadOpenDelayedCallback callback) {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   if (download_crx_util::IsExtensionDownload(*item) &&
+	  !download_crx_util::ShouldDownloadAsRegularFile() &&
       !extensions::WebstoreInstaller::GetAssociatedApproval(*item)) {
     scoped_refptr<extensions::CrxInstaller> crx_installer =
         download_crx_util::OpenChromeExtension(profile_, *item);
--- a/chrome/browser/download/download_crx_util.cc
+++ b/chrome/browser/download/download_crx_util.cc
@@ -6,6 +6,7 @@
 
 #include "chrome/browser/download/download_crx_util.h"
 
+#include "base/command_line.h"
 #include "chrome/browser/chrome_notification_types.h"
 #include "chrome/browser/extensions/crx_installer.h"
 #include "chrome/browser/extensions/extension_install_prompt.h"
@@ -126,6 +127,14 @@ scoped_refptr<extensions::CrxInstaller>
   return installer;
 }
 
+bool ShouldDownloadAsRegularFile() {
+  const base::CommandLine& command_line =
+    *base::CommandLine::ForCurrentProcess();
+  return command_line.HasSwitch("extension-mime-request-handling") &&
+    command_line.GetSwitchValueASCII("extension-mime-request-handling") ==
+    "download-as-regular-file";
+}
+
 bool IsExtensionDownload(const DownloadItem& download_item) {
   if (download_item.GetTargetDisposition() ==
       DownloadItem::TARGET_DISPOSITION_PROMPT)
--- a/chrome/browser/download/download_crx_util.h
+++ b/chrome/browser/download/download_crx_util.h
@@ -43,6 +43,10 @@ scoped_refptr<extensions::CrxInstaller>
     Profile* profile,
     const download::DownloadItem& download_item);
 
+// Returns true if the user wants all extensions to be downloaded as regular
+// files.
+bool ShouldDownloadAsRegularFile();
+
 // Returns true if this is an extension download. This also considers user
 // scripts to be extension downloads, since we convert those automatically.
 bool IsExtensionDownload(const download::DownloadItem& download_item);
--- a/chrome/browser/download/download_item_model.cc
+++ b/chrome/browser/download/download_item_model.cc
@@ -540,16 +540,16 @@ bool DownloadItemModel::IsCommandEnabled
       return download_->CanShowInFolder();
     case DownloadCommands::OPEN_WHEN_COMPLETE:
       return download_->CanOpenDownload() &&
-             !download_crx_util::IsExtensionDownload(*download_);
+             !IsExtensionDownload();
     case DownloadCommands::PLATFORM_OPEN:
       return download_->CanOpenDownload() &&
-             !download_crx_util::IsExtensionDownload(*download_);
+             !IsExtensionDownload();
     case DownloadCommands::ALWAYS_OPEN_TYPE:
       // For temporary downloads, the target filename might be a temporary
       // filename. Don't base an "Always open" decision based on it. Also
       // exclude extensions.
       return download_->CanOpenDownload() &&
-             !download_crx_util::IsExtensionDownload(*download_);
+             !IsExtensionDownload();
     case DownloadCommands::PAUSE:
       return !download_->IsSavePackageDownload() &&
              DownloadUIModel::IsCommandEnabled(download_commands, command);
@@ -576,7 +576,7 @@ bool DownloadItemModel::IsCommandChecked
   switch (command) {
     case DownloadCommands::OPEN_WHEN_COMPLETE:
       return download_->GetOpenWhenComplete() ||
-             download_crx_util::IsExtensionDownload(*download_);
+             IsExtensionDownload();
     case DownloadCommands::ALWAYS_OPEN_TYPE:
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
       if (download_commands->CanOpenPdfInSystemViewer()) {
@@ -746,7 +746,13 @@ std::string DownloadItemModel::GetMimeTy
 }
 
 bool DownloadItemModel::IsExtensionDownload() const {
-  return download_crx_util::IsExtensionDownload(*download_);
+  // Derivation of boolean statement:
+  // In original code, "IsExtensionDownload" always meant the extension
+  // was installed.
+  // In ungoogled code, "IsExtensionDownload && !ShouldDownloadAsRegularFile"
+  // is true iff this extension is to be installed.
+  return download_crx_util::IsExtensionDownload(*download_) &&
+      !download_crx_util::ShouldDownloadAsRegularFile();
 }
 
 #if BUILDFLAG(FULL_SAFE_BROWSING)
--- a/chrome/browser/download/download_target_determiner.cc
+++ b/chrome/browser/download/download_target_determiner.cc
@@ -1018,10 +1018,12 @@ DownloadConfirmationReason DownloadTarge
     return DownloadConfirmationReason::SAVE_AS;
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
-  // Don't prompt for extension downloads if the installation site is white
-  // listed.
-  if (download_crx_util::IsTrustedExtensionDownload(GetProfile(), *download_))
-    return DownloadConfirmationReason::NONE;
+  if (!download_crx_util::ShouldDownloadAsRegularFile()) {
+    // Don't prompt for extension downloads.
+    if (download_crx_util::IsTrustedExtensionDownload(GetProfile(), *download_) ||
+        filename.MatchesExtension(extensions::kExtensionFileExtension))
+      return DownloadConfirmationReason::NONE;
+  }
 #endif
 
   // Don't prompt for file types that are marked for opening automatically.
--- a/chrome/browser/download/notification/download_item_notification.cc
+++ b/chrome/browser/download/notification/download_item_notification.cc
@@ -193,7 +193,7 @@ void RecordButtonClickAction(DownloadCom
 
 bool IsExtensionDownload(DownloadUIModel* item) {
   return item->download() &&
-         download_crx_util::IsExtensionDownload(*item->download());
+         item->IsExtensionDownload();
 }
 
 }  // namespace
--- a/chrome/browser/extensions/extension_management.cc
+++ b/chrome/browser/extensions/extension_management.cc
@@ -8,6 +8,7 @@
 
 #include "base/bind.h"
 #include "base/bind_helpers.h"
+#include "base/command_line.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/stl_util.h"
@@ -191,6 +192,13 @@ bool ExtensionManagement::IsInstallation
 bool ExtensionManagement::IsOffstoreInstallAllowed(
     const GURL& url,
     const GURL& referrer_url) const {
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  if (command_line.HasSwitch("extension-mime-request-handling") &&
+      command_line.GetSwitchValueASCII("extension-mime-request-handling") ==
+      "always-prompt-for-install") {
+    return true;
+  }
   // No allowed install sites specified, disallow by default.
   if (!global_settings_->has_restricted_install_sources)
     return false;
--- a/chrome/browser/extensions/webstore_installer.cc
+++ b/chrome/browser/extensions/webstore_installer.cc
@@ -510,7 +510,8 @@ void WebstoreInstaller::OnDownloadUpdate
 
       // Only wait for other notifications if the download is really
       // an extension.
-      if (!download_crx_util::IsExtensionDownload(*download)) {
+      if (!download_crx_util::IsExtensionDownload(*download) ||
+          download_crx_util::ShouldDownloadAsRegularFile()) {
         ReportFailure(kInvalidDownloadError, FAILURE_REASON_OTHER);
         return;
       }
